***************** 14.1 Device Special Files (Devices) *****************

Device driver: a unit of kernal code that implements a det of operations that correspond to input/output on this piece of hardware.

Universality of I/O: open(), close(), read(), write(), and friends work on all devices, block, character, or otherwise.


Character device: handle data on a character by character basis. Terminals and keyboards!

Block devices: handle data a block at a time. It's usually a multiple 512 bytes, think hard drives, flash storage, CD-ROMS, and stuff.


"mknode" allows you to create a device file. "make file system inode"

/dev/ is straightforward, you already know this stuff

/sys/ is a more organized alternative to /dev/.


Each device has a MAJOR and a MINOR number. The MAJOR number is used to identify the appropriate device driver for the device. The MINOR number is used to identify a device within the same MAJOR device class.

Here is the official listing of device numbers for the linux kernal: http://www.lanana.org/docs/device-list/devices-2.6+.txt


Physical block: smallest unit that a disk drive can read/write at a time.


======= DISK PARTITIONS =======

Each disk partition is treated as a separate device by the linux kernal (in /dev/)

A disk partition commonly holds one of the following:
	1. File system holding regular files and directories
	2. Data area, accessed in raw mode. Common in microcontrollers im assuming, and some database management systems.
	3. swap area.

Swap space:
	1. mkswap(8): makes a swap space
	2. swapon(): with CAP_SYS_ADMIN, process can notify kernal that a disk partition is to be used as a swap area.
	3. swapoff(): tells kernal to stop using partition as swap space.


/proc/swaps for info about currently enabled swap areas on the system.


***************** 14.1 FILE SYSTEMS *****************

mkfs: create a file system.

/proc/filesystems for a list of supported file systems the kernel supports


ext2 source code: http://e2fsprogs.sourceforge.net/ext2.html



======== FILE SYSTEM STRUCTURE ===========

locigal block: some multiple of contiguous physical blocks (which are usually 512 bytes). Som 512*2, 512*4, 512*8, etc.


A FILE SYSTEM CONTAINS THESE PARTS:
	1. Boot block: First block in the filesystem. The boot block is not used by the file system. It contains info the OS needs to boot.

	2. Superblock: Contains a lot of metadata about the filesystem such as:
		-- size of inode table
		-- size of logical blocks in the filesystem
		-- the size of the file system in logical blocks

	3. Inode table: each file or directory has an entry in the inode table. Contains various info about the file/directory. More to come later

	4. Data blocks - The data that actually forms the files and directories.

EXCEPTION IN ext2 and probably a lot of other filesystems:
	-- in ext2, after the boot block, the file system is broken into a set of block groups. each block group has a copy of thesuperblock, info about the superblock, copy of the inode table, and subsequent data blocks for this inode table. this is for optimisation reasons.


***************** 14.1 INODES *****************

inode: means index node. They are identified by their sequential location in inode table. If you do ls -li, it is the first number in the listing.

Inodes contain this information:
	1. File type (regular file, directory, symlink, character device)
	2. Owner (UID) for the file
	3. Group (GID) for the file
	4. Access permissions for three categories of user: owner, group, and other (rest of the world)
	5. Three timestamps: last access (ls -lu), last modification (ls -l), last status change (ls -lc). Interesting fact: most linux file systems do not record the creation time of a file.
	6. Number of hard links to the file
	7. Size of file in bytes
	8. Number of blocks actually allocated to the file, measured in 512 units. May not be a simple correspondance between this and size of file in bytes because of file holes.
	9. Pointers to data blocks of a file (see the diagram)

INODE STRUCTURE IN ext2:
	Contains 15 pointers to data file in each record. The first 12 point to the first 12 data blocks sequentially. The next 3 pointers are "indirection" pointers that point to pointers that point to the actual data in the file.



***************** 14.7 DIRECTORY HIERARCHY *****************

$ mount device directory

mount a device on a directory heirarchy

$ mount
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs (rw,nosuid,relatime,size=8151204k,nr_inodes=2037801,mode=755)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,noexec,relatime,size=1633908k,mode=755)
/dev/sda4 on / type ext4 (rw,relatime,errors=remount-ro,data=ordered)

1. device name
2. mount point
3. file system type
4. mount options

THIS IS THE SAME AS:

$ cat /proc/mounts

OR /proc/PID/mounts OR /proc/self/mounts

Also, newer linux kernals can have per-process mount namespaces, so a directory hierarchy may look different from process to process.


/etc/mtab: THIS ONE IS NOT AN INTERFACE TO KERNAL DATA STRUCTURES. So be sure to update this in your program if it happens to mount/unmount and you want to rely on this file... Sounds like a file to not rely on though


mount(8) and umount(8) keep /etc/mtab up to date

your programs probably should too, other programs depend on it.

The /etc/fstab file, maintained manually by the system administrator, contains
descriptions of all of the available file systems on a system, and is used by the
mount(8), umount(8), and fsck(8) commands.


getfsent(3) and getmntent(3), look them up later...


============= mount() =============

#include <sys/mount.h>

int mount(const char *source, const char *target, const char *fstype, unsigned long mountflags, const void *data);

returns 0 on success, -1 on error

const char *source: device name, ex "/dev/sda1"
const char *target: mounting point, ex "/" or "/home/testdir/"
const char *fstype: file system type, ex "ext2", "fat32", "ext4"

unsigned long mountflags:

	MS_BIND Create a bind mount (since Linux 2.4)

	MS_DIRSYNC Make directory updates synchronous (since Linux 2.6)

	MS_MANDLOCK Permit mandatory locking of files

	MS_MOVE Atomically move mount point to new location

	MS_NOATIME Don’t update last access time for files

	MS_NODEV Don’t allow access to devices

	MS_NODIRATIME Don’t update last access time for directories

	MS_NOEXEC Don’t allow programs to be executed

	MS_NOSUID Disable set-user-ID and set-group-ID programs

	MS_RDONLY Read-only mount; files can’t be created or modified

	MS_REC Recursive mount (since Linux 2.4.11)

	MS_RELATIME Update last access time only if older than last modification time or last status change time (since Linux 2.6.20)

	MS_REMOUNT Remount with new mountflags and data

	MS_STRICTATIME Always update last access time (since Linux 2.6.30)

	MS_SYNCHRONOUS Make all file and directory updates synchronous

const void *data: 